/* Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/debugfs.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <media/cam_req_mgr.h>
#include "cam_debug_util.h"
#include "cam_sensor_vsync.h"
#include "cam_sensor_core.h"
#include "cam_sensor_util.h"
#include "cam_soc_util.h"
#include "cam_trace.h"
#include "cam_common_util.h"
#include <linux/qrtr.h>
#include <linux/net.h>
#include <linux/completion.h>
#include <linux/idr.h>
#include <linux/string.h>
#include <net/sock.h>
#include <linux/soc/qcom/qmi.h>


struct vsync_ctx_type {
	struct qmi_handle qmi;
	struct workqueue_struct *work_queue;
	struct dentry *de_dir;
	struct dentry *de_data;
};

struct cam_vsync_work_payload {
	struct vsync_ctx_type *ctx;
	struct cam_sensor_vsync_packet packet;
	struct work_struct work;
};

struct cam_vsync_req_msg_v01 {
	uint32_t data_len;
	uint8_t data[CAM_VSYNC_DATA_SIZE_V01];

	/* Optional */
	/**< Must be set to true if use_jumbo_report is being passed */
	uint8_t use_jumbo_report_valid;
	uint8_t use_jumbo_report;
};

static struct qmi_elem_info cam_vsync_req_msg_v01_ei[] = {
	{
		.data_type	= QMI_DATA_LEN,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_REQ1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   data_len),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= CAM_VSYNC_DATA_SIZE_V01,
		.elem_size	= sizeof(uint8_t),
		.is_array	= VAR_LEN_ARRAY,
		.tlv_type	= CAM_VSYNC_REQ1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   data),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   use_jumbo_report_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_1_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_req_msg_v01,
					   use_jumbo_report),
	},
	{}
};

struct cam_vsync_resp_msg_v01 {

	/* Mandatory */
	struct qmi_response_type_v01 resp;

	/* Optional */
	/* Must be set to true if client_id is being passed */
	uint8_t client_id_valid;
	uint64_t client_id;
	/*  Client ID identifies the client connection. */
	/*  Generated by service, and returned in all */
	/*  sns_client_report_ind_msg.  Will be the same value in all */
	/*  sns_client_resp_msg/sns_client_report_ind_msg for */
	/*  this client connection. */

	/* Optional */
	/* Must be set to true if result is being passed */
	uint8_t result_valid;
	uint32_t result;
	/* Result status of the request; see sns_pb_error_type */
};/* Message */


static struct qmi_elem_info cam_vsync_resp_msg_v01_ei[] = {
	{
		.data_type	= QMI_STRUCT,
		.elem_len	= 1,
		.elem_size	= sizeof(struct qmi_response_type_v01),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_RESP1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   resp),
		.ei_array	= qmi_response_type_v01_ei,
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
						client_id_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_8_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(u64),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT1_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
						client_id),
	},
	{
		.data_type	= QMI_OPT_FLAG,
		.elem_len	= 1,
		.elem_size	= sizeof(uint8_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT2_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   result_valid),
	},
	{
		.data_type	= QMI_UNSIGNED_4_BYTE,
		.elem_len	= 1,
		.elem_size	= sizeof(uint32_t),
		.is_array	= NO_ARRAY,
		.tlv_type	= CAM_VSYNC_OPT2_TLV_TYPE,
		.offset		= offsetof(struct cam_vsync_resp_msg_v01,
					   result),
	},
	{}
};


static struct vsync_ctx_type cam_vsync_ctx;
static void cam_vsync_qmi_work(struct work_struct *work);

static int cam_send_vsync_packet_qmi(struct qmi_handle *qmi,
			struct cam_sensor_vsync_packet *packet)
{
	struct cam_vsync_resp_msg_v01 *resp;
	struct cam_vsync_req_msg_v01 *req;
	struct qmi_txn txn;
	int ret = 0;

	if (!packet) {
		CAM_ERR(CAM_SENSOR, "%s: packet is NULL", __func__);
		return -EINVAL;
	}

	if (!qmi) {
		CAM_ERR(CAM_SENSOR, "%s: QMI handle is NULL", __func__);
		return -EINVAL;
	}

	req = kzalloc(sizeof(*req), GFP_KERNEL);
	if (!req)
		return -ENOMEM;

	resp = kzalloc(sizeof(*resp), GFP_KERNEL);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	cam_vsync_make_sensor_request(packet, req->data, &req->data_len);
	req->use_jumbo_report_valid = false;

	CAM_DBG(CAM_SENSOR,
			"Notify camera:%d, counter:%d, timestamp:%lld",
			packet->sensor_id,
			packet->counter,
			packet->timestamp);

	ret = qmi_txn_init(qmi, &txn, cam_vsync_resp_msg_v01_ei, resp);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_txn_init failed. %d", ret);
		goto out;
	}

	ret = qmi_send_request(qmi, NULL, &txn,
				CAM_VSYNC_REQ_MSG_ID_V01,
				sizeof(struct cam_vsync_req_msg_v01),
				cam_vsync_req_msg_v01_ei,
				req);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_send_request failed. %d", ret);
		qmi_txn_cancel(&txn);
		goto out;
	}

	ret = qmi_txn_wait(&txn, 5 * HZ);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR, "%s:qmi_txn_wait failed. %d", ret);
		goto out;
	}
	CAM_DBG(CAM_SENSOR, "Received Resp result = %d, err = %d",
		resp->resp.result,
		resp->resp.error);

out:
	kfree(resp);
	kfree(req);

	return ret;
}

int cam_notify_vsync_qmi(struct cam_req_mgr_message *msg)
{
	struct cam_vsync_work_payload *payload;
	bool work_status;
	int i, rc = 0;
	struct cam_req_mgr_core_link    *link = NULL;
	struct cam_req_mgr_connected_device *dev = NULL;
	struct cam_sensor_ctrl_t *s_ctrl = NULL;
	uint32_t sensor_id = 0;

	if (!msg) {
		CAM_ERR(CAM_CRM, "msg is NULL");
		return -EINVAL;
	}

	link = (struct cam_req_mgr_core_link *)
		cam_get_device_priv(msg->u.frame_msg.link_hdl);
	if (!link) {
		CAM_DBG(CAM_CRM, "link ptr NULL %x",
			msg->u.frame_msg.link_hdl);
		return -EINVAL;
	}
	for (i = 0; i < link->num_devs; i++) {
		dev = &link->l_dev[i];
		if (!dev)
			continue;
		if (dev->dev_info.dev_id != CAM_REQ_MGR_DEVICE_SENSOR)
			continue;
		s_ctrl = (struct cam_sensor_ctrl_t *)
			cam_get_device_priv(dev->dev_info.dev_hdl);

		if (!s_ctrl) {
			CAM_ERR(CAM_SENSOR, "Device data is NULL");
			return -EINVAL;
		}
		/* Kernel    REAR_WIDE REAR_TELE FRONT_CAM */
		/* Userspace REAR_WIDE FRONT_CAM REAR_TELE */
		sensor_id = s_ctrl->soc_info.index;
		switch (s_ctrl->soc_info.index) {
		case 0:
			sensor_id = 0;
			break;
		case 1:
			sensor_id = 2;
			break;
		case 2:
			sensor_id = 1;
			break;
		default:
			break;
		}
	}

	payload = kzalloc(sizeof(struct cam_vsync_work_payload), GFP_ATOMIC);
	if (!payload) {
		rc = -ENOMEM;
	} else {
		payload->ctx = &cam_vsync_ctx;
		if (!msg->u.frame_msg.sof_status) {
			payload->packet.sensor_id = sensor_id;
			payload->packet.counter = msg->u.frame_msg.frame_id;
			payload->packet.timestamp = msg->u.frame_msg.timestamp;
		}

		INIT_WORK((struct work_struct *)&payload->work,
			cam_vsync_qmi_work);
		work_status = queue_work(cam_vsync_ctx.work_queue,
				&payload->work);
		if (work_status == false) {
			CAM_ERR(CAM_SENSOR, "Failed to queue work");
			rc = -EINVAL;
		}
	}
	return rc;
}
EXPORT_SYMBOL(cam_notify_vsync_qmi);

static void cam_vsync_qmi_work(struct work_struct *work)
{
	struct cam_vsync_work_payload *payload;
	struct vsync_ctx_type *ctx;
	struct qmi_handle *qmi;

	if (!work)
		return;

	payload = container_of(work, struct cam_vsync_work_payload, work);
	ctx = payload->ctx;
	if (ctx) {
		qmi = &ctx->qmi;
		if (qmi)
			cam_send_vsync_packet_qmi(qmi, &payload->packet);
	}
	/* Free the payload packet after use */
	kfree(payload);
}

static int cam_vsync_read(void *data, u64 *val)
{
	*val = 0;
	return 0;
}

static int cam_vsync_write(void *data, u64 val)
{
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;
	struct qmi_handle *qmi = &ctx->qmi;
	struct cam_sensor_vsync_packet packet;
	int ret;

	packet.sensor_id = 0;
	packet.counter = 0;
	packet.timestamp = val;
	ret = cam_send_vsync_packet_qmi(qmi, &packet);

	return ret;
}

DEFINE_SIMPLE_ATTRIBUTE(cam_vsync_qmi_fops,
	cam_vsync_read,
	cam_vsync_write, "%16llu");

static struct dentry *cam_vsync_debug_dir;

static int cam_vsync_probe(struct platform_device *pdev)
{
	struct sockaddr_qrtr *sq;
	struct vsync_ctx_type *ctx = &cam_vsync_ctx;
	char path[20];
	int ret;

	ret = qmi_handle_init(&ctx->qmi, CAM_VSYNC_REQ_MAX_MSG_LEN_V01,
				NULL,
				NULL);
	if (ret < 0)
		return ret;

	sq = dev_get_platdata(&pdev->dev);
	ret = kernel_connect(ctx->qmi.sock, (struct sockaddr *)sq,
				sizeof(*sq), 0);
	if (ret < 0) {
		CAM_ERR(CAM_SENSOR,
			"failed to connect to remote service port\n");
		goto err_release_qmi_handle;
	}

	snprintf(path, sizeof(path), "%d:%d", sq->sq_node, sq->sq_port);

	ctx->de_dir = debugfs_create_dir(path, cam_vsync_debug_dir);
	if (IS_ERR(ctx->de_dir)) {
		ret = PTR_ERR(ctx->de_dir);
		goto err_release_qmi_handle;
	}

	ctx->de_data = debugfs_create_file("data", 0600, ctx->de_dir,
						NULL, &cam_vsync_qmi_fops);
	if (IS_ERR(ctx->de_data)) {
		ret = PTR_ERR(ctx->de_data);
		goto err_remove_de_dir;
	}

	platform_set_drvdata(pdev, ctx);

	return 0;

err_remove_de_dir:
	debugfs_remove(ctx->de_dir);
err_release_qmi_handle:
	qmi_handle_release(&ctx->qmi);

	return ret;
}

static int cam_vsync_remove(struct platform_device *pdev)
{
	struct vsync_ctx_type *ctx = platform_get_drvdata(pdev);

	debugfs_remove(ctx->de_data);
	debugfs_remove(ctx->de_dir);

	qmi_handle_release(&ctx->qmi);

	return 0;
}

static struct platform_driver cam_vsync_driver = {
	.probe = cam_vsync_probe,
	.remove = cam_vsync_remove,
	.driver = {
		.name = "cam_vsync_client",
	},
};

static int cam_vsync_new_server(struct qmi_handle *qmi,
				 struct qmi_service *service)
{
	struct platform_device *pdev;
	struct sockaddr_qrtr sq = { AF_QIPCRTR, service->node, service->port };
	int ret;

	pdev = platform_device_alloc("cam_vsync_client", PLATFORM_DEVID_AUTO);
	if (!pdev)
		return -ENOMEM;

	ret = platform_device_add_data(pdev, &sq, sizeof(sq));
	if (ret)
		goto err_put_device;

	ret = platform_device_add(pdev);
	if (ret)
		goto err_put_device;

	service->priv = pdev;

	return 0;

err_put_device:
	platform_device_put(pdev);

	return ret;
}

static void cam_vsync_del_server(struct qmi_handle *qmi,
				  struct qmi_service *service)
{
	struct platform_device *pdev = service->priv;

	platform_device_unregister(pdev);
}

static struct qmi_handle lookup_client;

static struct qmi_ops lookup_ops = {
	.new_server = cam_vsync_new_server,
	.del_server = cam_vsync_del_server,
};

static int cam_vsync_init(void)
{
	int ret;

	cam_vsync_debug_dir = debugfs_create_dir("cam_vsync_qmi", NULL);
	if (IS_ERR(cam_vsync_debug_dir)) {
		CAM_ERR(CAM_SENSOR, "failed to create qmi_vsync dir\n");
		return PTR_ERR(cam_vsync_debug_dir);
	}

	ret = platform_driver_register(&cam_vsync_driver);
	if (ret)
		goto err_remove_debug_dir;

	ret = qmi_handle_init(&lookup_client, 0, &lookup_ops, NULL);
	if (ret < 0)
		goto err_unregister_driver;

	qmi_add_lookup(&lookup_client, SNS_CLIENT_SVC_ID_V01, 0, 0);

	cam_vsync_ctx.work_queue = alloc_workqueue("cam_vsync_client",
		WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS,
		CAM_VSYNC_INFLIGHT_WORKS);

	return 0;

err_unregister_driver:
	platform_driver_unregister(&cam_vsync_driver);
err_remove_debug_dir:
	debugfs_remove(cam_vsync_debug_dir);

	return ret;
}

static void cam_vsync_exit(void)
{
	flush_workqueue(cam_vsync_ctx.work_queue);
	destroy_workqueue(cam_vsync_ctx.work_queue);

	qmi_handle_release(&lookup_client);

	platform_driver_unregister(&cam_vsync_driver);

	debugfs_remove(cam_vsync_debug_dir);
}

module_init(cam_vsync_init);
module_exit(cam_vsync_exit);

MODULE_DESCRIPTION("Camera VSync QMI client driver");
MODULE_LICENSE("GPL v2");
