/* Copyright (c) 2017, The Linux Foundation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
 * only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <dt-bindings/interrupt-controller/irq.h>
#include <dt-bindings/clock/abc-clk.h>
#include <dt-bindings/gpio/gpio.h>

#include "sm8150-floral-airbrush-trip-points.dtsi"

&pcie1 {
	/* QCOM's GICM implementation is not compatible with Airbrush */
	qcom,msi-gicm-addr = <>;
	qcom,msi-gicm-base = <>;

	/* reduce endpoint reset latency */
	qcom,ep-latency = <1>;
};

&tlmm {
	s2mpb04_pins {
		s2mpb04_pon_default: s2mpb04_pon_default {
			mux {
				pins = "gpio29";
				function = "gpio";
			};

			config {
				pins = "gpio29";
				drive-strength = <2>;
				bias-disable;
			};
		};

		s2mpb04_intb_default: s2mpb04_intb_default {
			mux {
				pins = "gpio41";
				function = "gpio";
			};

			config {
				pins = "gpio41";
				drive-strength = <2>;
				bias-pull-up;
			};
		};
	};
};

&pm8150l_gpios {
	airbrush_fw {
		ab_fw_patch_en_default: ab_fw_patch_en_default {
			pins = "gpio1";
			function = "normal";
			output-low;
		};
	};

	airbrush_abready {
		ab_ready_default: ab_ready_default {
			pins = "gpio10";
			function = "normal";
			input-enable;
			bias-disable;
			power-source = <1>;	/* 1.8V input supply */
		};
	};

	airbrush_pmic_ready {
		ab_pmic_ready_default: ab_pmic_ready_default {
			pins = "gpio11";
			function = "normal";
			input-enable;
			bias-disable;
			power-source = <1>;	/* 1.8V input supply */
		};
	};
};

&qupv3_se18_i2c {
	status = "okay";
	airbrush_pmic: s2mpb04@66 {
		compatible = "samsung,s2mpb04";
		reg = <0x66>;

		interrupt-parent = <&tlmm>;
		interrupts = <41 IRQ_TYPE_EDGE_FALLING>;
		interrupt-names = "s2mpb04_intb";

		pinctrl-names = "default";
		pinctrl-0 = <&s2mpb04_pon_default
					 &s2mpb04_intb_default
					 &ab_pmic_ready_default>;

		samsung,pon-gpio = <&tlmm 29 0x00>;
		samsung,intb-gpio = <&tlmm 41 0x00>;
		samsung,pmic-ready-gpio = <&pm8150l_gpios 11 GPIO_ACTIVE_HIGH>;

		s2mpb04_regulator: regulator {
			compatible = "samsung,s2mpb04-regulator";
		};

		s2mpb04_gpio: gpio {
			compatible = "samsung,s2mpb04-gpio";
			gpio-controller;
			#gpio-cells = <2>;
		};

		s2mpb04_thermal: sensor {
			compatible = "samsung,s2mpb04-thermal";
			#thermal-sensor-cells = <0>;
		};
	};
};

&qupv3_se10_spi {
	status = "okay";
	airbrush-spi@0 {
		status = "okay";
		compatible = "abc,airbrush-spi";
		reg = <0>;
		spi-max-frequency = <1000000>;
	};
	airbrush-spidev@0 {
		status = "disabled";
		compatible = "abc,airbrush-spidev";
		reg = <0>;
		spi-max-frequency = <1000000>;
	};
};

&soc {

	fin_pll_ab: xxti_ab {
		compatible = "fixed-clock";
		clock-output-names = "fin_pll_ab";
		clock-frequency = <19200000>;
		#clock-cells = <0>;
	};
	ppmu_pcie_m: ppmu_pcie_m@41fa0000 {
		compatible = "abc,airbrush-ppmu-v2";
		reg = <0x0 0x41fa0000 0x0 0x300>;
		interrupt = <42>;
		status = "okay";
	};

	ppmu_pcie_s: ppmu_pcie_s@41fb0000 {
		compatible = "abc,airbrush-ppmu-v2";
		reg = <0x0 0x41fb0000 0x0 0x300>;
		interrupt = <43>;
		status = "okay";
	};

	ppmu_tpu: ppmu_tpu@41f90000 {
		compatible = "abc,airbrush-ppmu-v2";
		reg = <0x0 0x41f90000 0x0 0x300>;
		interrupt = <41>;
		status = "okay";
	};

	ppmu_ipu: ppmu_ipu@41f80000 {
		compatible = "abc,airbrush-ppmu-v2";
		reg = <0x0 0x41f80000 0x0 0x300>;
		interrupt = <40>;
		status = "okay";
	};

	airbrush_tmu: tmu@10b90000 {
		compatible = "abc,airbrush-tmu";
		reg = <0x0 0x10B90000 0x0 0x300>;
		interrupt = <0>;
		status = "okay";
		#thermal-sensor-cells = <0>;
	};

	abc_sm: abc-sm {
		compatible = "abc,airbrush-sm";

		clocks = <&fin_pll_ab>,
			<&clock_ipu FOUT_PLL_IPU>,
			<&clock_ipu MOUT_IPU_PLL_IPU>,
			<&clock_ipu DOUT_IPU_IPU_PLL_CLK_DIV_1>,
			<&clock_ipu MOUT_IPU_AONCLK_PLLCLK1>,
			<&clock_ipu CLK_BLK_IPU_UID_IPU_IPCLKPORT_CLK_IPU>,
			<&clock_aon DOUT_AON_SHARED_DIV_AON_PLL>,
			<&clock_tpu FOUT_PLL_TPU>,
			<&clock_tpu MOUT_TPU_PLL_TPU>,
			<&clock_tpu DOUT_TPU_TPU_PLL_DIV_CLK_1>,
			<&clock_tpu MOUT_TPU_AONCLK_PLLCLK>,
			<&clock_tpu CLK_BLK_TPU_UID_TPU_IPCLKPORT_CLK_TPU>,
			<&clock_rpmh RPMH_LN_BB_CLK2>;
		clock-names =	"osc_clk",
				"ipu_pll",
				"ipu_pll_mux",
				"ipu_pll_div",
				"ipu_switch_mux",
				"ipu_gate_clk",
				"shared_div_aon_pll",
				"tpu_pll",
				"tpu_pll_mux",
				"tpu_pll_div",
				"tpu_switch_mux",
				"tpu_gate_clk",
				"ab_ref";

		/* Provide GPIOs used in Airbrush boot sequence */
		ab-ready-gpio = <&pm8150l_gpios 10 GPIO_ACTIVE_HIGH>;
		fw-patch-en-gpio = <&pm8150l_gpios 1 GPIO_ACTIVE_HIGH>;
		soc-pwrgood-gpio = <&s2mpb04_gpio 0 GPIO_ACTIVE_HIGH>;
		ddr-iso-gpio = <&s2mpb04_gpio 1 GPIO_ACTIVE_HIGH>;
		ddr-sr-gpio = <&s2mpb04_gpio 2 GPIO_ACTIVE_HIGH>;

		pinctrl-names = "default";
		pinctrl-0 = <&ab_ready_default &ab_fw_patch_en_default>;

		host-gpio-ctrl = <1>;
		otp-fw-patch-dis = <0>;
		/* In case "otp-fw-patch-dis" is zero, user can try to boot ABC
		 * in alternate boot mode (using spi-fsm). This property will
		 * let the state manager know the current boot method to follow
		 * is alternate boot when set to 1.
		 */
		ab-alternate-boot = <1>;
		/* OTP: if this bit is set, the DDR OTP values are already
		 * updated in the OTP memory of ABC
		 */
		ddr-otp-flashed = <0>;

		clock_aon: clock-controller@41B10000 {
			compatible = "diablo,abc-clock-aon";
			reg = <0x41B10000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>;
			clock-names = "fin_pll_ab";
			status = "okay";
		};

		clock_core: clock-controller@41F10000 {
			compatible = "diablo,abc-clock-core";
			reg = <0x41F10000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>,
				<&clock_aon DOUT_AON_PLL_AON_CLK>;
			clock-names = "fin_pll",
				"dout_aon_pll_aon_clk";
			status = "okay";
		};

		clock_fsys: clock-controller@41710000 {
			compatible = "diablo,abc-clock-fsys";
			reg = <0x41710000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>,
				<&clock_aon DOUT_AON_PLL_AON_CLK>;
			clock-names = "fin_pll",
				"dout_aon_pll_aon_clk";
			status = "okay";
		};

		clock_mif: clock-controller@41510000 {
			compatible = "diablo,abc-clock-mif";
			reg = <0x41510000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>,
				<&clock_aon DOUT_AON_PLL_AON_CLK>,
				<&clock_aon DOUT_AON_SHARED_DIV_MIF>;
			clock-names = "fin_pll",
				"dout_aon_pll_aon_clk",
				"dout_aon_shared_div_mif";
			status = "okay";
		};

		clock_ipu: clock-controller@41240000 {
			compatible = "diablo,abc-clock-ipu";
			reg = <0x41240000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>,
				<&clock_aon DOUT_AON_PLL_AON_CLK>,
				<&clock_aon DOUT_AON_SHARED_DIV_AON_PLL>;
			clock-names = "fin_pll",
				"dout_aon_pll_aon_clk",
				"dout_aon_shared_div_aon_pll";
			status = "okay";
		};

		clock_tpu: clock-controller@41040000 {
			compatible = "diablo,abc-clock-tpu";
			reg = <0x41040000 0x10000>;
			#clock-cells = <1>;
			clocks = <&fin_pll_ab>,
				<&clock_aon DOUT_AON_PLL_AON_CLK>,
			<&clock_aon DOUT_AON_SHARED_DIV_AON_PLL>;
			clock-names = "fin_pll",
				"dout_aon_pll_aon_clk",
			"dout_aon_shared_div_aon_pll";
			status = "okay";
		};
	};
};

